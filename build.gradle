// minecraftforge 1.12.2 mod dev

buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven {
            name = "forge"
            url = "https://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
    }
}

plugins {
    id 'com.palantir.git-version' version '0.13.0' apply false
}

apply plugin: 'net.minecraftforge.gradle.forge'

if (project.file('.git/HEAD').isFile()) {
    apply plugin: 'com.palantir.git-version'
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
    throw new GradleException("This project requires Java 8, but it's running on " + JavaVersion.current())
}

checkPropertyExists("mod_name")
checkPropertyExists("mod_id")
checkPropertyExists("mod_group")
checkPropertyExists("minecraft_version")
checkPropertyExists("forge_version")
checkPropertyExists("mcp_mappings")
checkPropertyExists("replace_gradle_token_in_file")
checkPropertyExists("gradle_token_mod_id")
checkPropertyExists("gradle_token_mod_name")
checkPropertyExists("gradle_token_version")
checkPropertyExists("gradle_token_group_name")
checkPropertyExists("development_environment_username")

String identified_version
String version_override = System.getenv("VERSION") ?: null
try {
    identified_version = (version_override == null) ? gitVersion() : version_override
} catch (Exception ignored) {
    println('This mod must be version controlled by Git AND the repository must provide at least one tag,\n' +
            'or the VERSION override must be set!')
    version_override = 'NO-GIT-TAG-SET'
    identified_version = version_override
}
version = minecraft_version + '-' + identified_version
ext {
    mod_version = identified_version
}

if (identified_version == version_override) {
    println("Override version to ${mod_version}")
}

group = mod_group

if (project.hasProperty("customArchiveBaseName") && customArchiveBaseName) {
    archivesBaseName = customArchiveBaseName
} else {
    archivesBaseName = mod_id
}

def arguments = []
def jvmArguments = []

minecraft {
    version = minecraft_version + "-" + forge_version
    runDir = "run"
    mappings = mcp_mappings

    if (replace_gradle_token_in_file) {
        for (f in replace_gradle_token_in_file.split(',')) {
            replaceIn f
        }
        if (gradle_token_mod_id) {
            replace gradle_token_mod_id, mod_id
        }
        if (gradle_token_mod_name) {
            replace gradle_token_mod_name, mod_name
        }
        if (gradle_token_version) {
            replace gradle_token_version, mod_version
        }
        if (gradle_token_group_name) {
            replace gradle_token_group_name, mod_group
        }
    }
}

apply from: 'dependencies.gradle'

runClient {
    if (development_environment_username) {
        arguments += [
            "--username",
            development_environment_username
        ]
    }

    args(arguments)
    jvmArgs(jvmArguments)
}

runServer {
    args(arguments)
    jvmArgs(jvmArguments)
}

jar {
    manifest {
        attributes 'FMLAT': mod_id + '_at.cfg'
    }
}

jar.finalizedBy('reobfJar')

task determinizeJar(type: Zip) {
    dependsOn reobfJar
    def jarPath = reobfJar.jar
    from zipTree(jarPath)
    archiveName = jarPath.name
    destinationDir = temporaryDir
    doLast {
        copy {
            from archivePath
            into jarPath.parent
        }
        archivePath.delete()
    }
}

tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

reobfJar.finalizedBy('determinizeJar')

processResources {
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        expand "version":project.version,
               "minecraftVersion": project.minecraft.version,
               "modVersion": mod_version,
               "modId": mod_id,
               "modName": mod_name
    }

    from(sourceSets.main.resources.srcDirs) {
        include 'assets/' + mod_id + '/lang/*.json'

        eachFile { fileInfo ->
            def matcher = fileInfo.name =~ /^([a-zA-Z0-9]+)_([a-zA-Z0-9]+).json$/
            matcher.find()
            def language = matcher.group(1)
            def region = matcher.group(2)
            def fileName = language + '_' + region.toUpperCase() + '.lang'
            def filePath = fileInfo.relativePath.parent.append(true, fileName)
            def langFile = new File(destinationDir, filePath.pathString)
            def translation = new groovy.json.JsonSlurper().parse(file)
            langFile.withWriter { wr ->
                translation.each { e ->
                    wr.println e.key + '=' + e.value
                }
            }
            fileInfo.exclude()
            def jsonFile = new File(destinationDir, fileInfo.path)
            jsonFile.text = '{}\n'
        }
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'assets/' + mod_id + '/lang/*.json'
        exclude 'mcmod.info'
        exclude 'pack.mcmeta'
        exclude 'pack.png'
    }

    doLast {
        fileTree(dir: destinationDir, include: 'assets/' + mod_id + '/lang/*.json').each { file ->
            file.delete()
        }
    }
}

def checkPropertyExists(String propertyName) {
    if (!project.hasProperty(propertyName)) {
        throw new GradleException("This project requires a property \"" +
                                  propertyName + "\"! Please add it your \"gradle.properties\".")
    }
}

def propertyDefaultIfUnset(String propertyName, defaultValue) {
    if (!project.hasProperty(propertyName) || project.property(propertyName) == "") {
        project.ext.setProperty(propertyName, defaultValue)
    }
}
